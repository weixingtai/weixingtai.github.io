<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    第1章 创建你的第一个Compose应用 |
    
    鸭梨西瓜大
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-第1章 创建你的第一个Compose应用" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  第1章 创建你的第一个Compose应用
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2022/06/06/%E7%AC%AC1%E7%AB%A0%20%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AACompose%E5%BA%94%E7%94%A8/" class="article-date">
  <time datetime="2022-06-06T07:37:05.189Z" itemprop="datePublished">2022-06-06</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h1 id="第1章-创建你的第一个Compose应用"><a href="#第1章-创建你的第一个Compose应用" class="headerlink" title="第1章 创建你的第一个Compose应用"></a>第1章 创建你的第一个Compose应用</h1><p>Jetpack Compose是谷歌针对Android的声明式UI框架，它大大简化了UI的创建。但在进一步学习之前，我们知道，Jetpack Compose仅适用于Kotlin。这意味着我们接下来创建的工程都必须用Kotlin编程。所以在学习本专题之前，读者应该对Kotlin语法和函数式编程有基本的了解。后续我会陆续推出关于Kotlin的专题，欢迎一起学习交流。</p>
<h5 id="本章包含以下三个主题："><a href="#本章包含以下三个主题：" class="headerlink" title="本章包含以下三个主题："></a>本章包含以下三个主题：</h5><ul>
<li>第一个Compose程序：HelloWord</li>
<li>使用预览函数</li>
<li>运行 Compose 项目</li>
</ul>
<h2 id="（一）第一个Compose程序：HelloWord"><a href="#（一）第一个Compose程序：HelloWord" class="headerlink" title="（一）第一个Compose程序：HelloWord"></a>（一）第一个Compose程序：HelloWord</h2><p>接下来你会看到，在Jetpack Compose中，可组合函数是UI的基本元素，通过可组合函数我们可以构建复杂的UI界面。所以我们首先通过一个HelloWord程序来学习可组合函数。这个程序会有一个输入名称的按钮还有完成按钮，输入名字点击完成后，界面会出现一段问候文本。<br>根据需求分析，这个程序包含以下内容：</p>
<ul>
<li>第一是一段欢迎文本</li>
<li>第二是一个输入框和一个完成按钮</li>
<li>第三是一段问候文本</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/12661360-3011efed591bb408.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HelloWord"></p>
<p>接下来让我们马上开始吧！</p>
<h3 id="1-一段欢迎文本"><a href="#1-一段欢迎文本" class="headerlink" title="1.一段欢迎文本"></a>1.一段欢迎文本</h3><p>接下来我们编写我们的第一个Compose函数，一段欢迎文本。<br>MainActivity.kt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun Welcome() &#123;</span><br><span class="line">    Text(text = stringResource(id = R.string.welcome),</span><br><span class="line">    style = MaterialTheme.typography.subtitle1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>strings.xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;string name=&quot;welcome&quot;&gt;欢迎&lt;/string&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以通过**@Composable**注解来标识可组合函数。它们不需要有特定的返回类型，而是发出界面元素，从而被其他可组合函数调用。Composable表示函数&#x2F;lambda表达式可作为组合的一部分，将应用程序数据转换为树或层次结构。<br>这个Welcome可组合函数里面包含一个Text()元素，他有两个参数，text参数引用了strings.xml文件的welcome文本，style参数调用了预置的Material主题的subtitle1。<br>接下来我们再创建一个@Composable函数，一段问候文本。看看与之前的Welcome函数有何不同？<br>MainActivity.kt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun Greeting(name: String) &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = stringResource(id = R.string.hello,name),</span><br><span class="line">        textAlign = TextAlign.Center,</span><br><span class="line">        style = MaterialTheme.typography.subtitle1</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的text参数我们使用了<strong>带参数name的文本</strong>，可以非常方便地替代文本中的变量。<br>strings.xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;string name=&quot;hello&quot;&gt;你好,%1$s.\n非常高兴见到你。&lt;/string&gt;</span><br></pre></td></tr></table></figure>
<p>上面的%1代表第一个参数，$s代表替代的文本。</p>
<h3 id="2-包含输入框和完成按钮的一行"><a href="#2-包含输入框和完成按钮的一行" class="headerlink" title="2.包含输入框和完成按钮的一行"></a>2.包含输入框和完成按钮的一行</h3><p>这个输入框和完成按钮在同一行，Row属于非常常见的<strong>三大基本布局（Row，Column，Box）</strong>之一。与其他的Composable函数一样，Row(){}，我们可以向小括号()里面传入若干参数，及向大括号{}里面传入若干子元素来组成界面。<br>MainActivity.kt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun TextAndButton(name: MutableState&lt;String&gt;, nameEntered: MutableState&lt;Boolean&gt;) &#123;</span><br><span class="line">    Row(modifier = Modifier.padding(top = 8.dp)) &#123;</span><br><span class="line">        TextField(</span><br><span class="line">            value = name.value,</span><br><span class="line">            onValueChange = &#123;</span><br><span class="line">                name.value = it</span><br><span class="line">            &#125;,</span><br><span class="line">            placeholder = &#123;</span><br><span class="line">                Text(text = stringResource(id = R.string.hint))</span><br><span class="line">            &#125;,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .alignByBaseline()</span><br><span class="line">                .weight(1.0F),</span><br><span class="line">            singleLine = true,</span><br><span class="line">            keyboardOptions = KeyboardOptions(</span><br><span class="line">                autoCorrect = false,</span><br><span class="line">                capitalization = KeyboardCapitalization.Words</span><br><span class="line">            ),</span><br><span class="line">            keyboardActions = KeyboardActions(onAny = &#123;</span><br><span class="line">                nameEntered.value = true</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">        Button(modifier = Modifier</span><br><span class="line">            .alignByBaseline()</span><br><span class="line">            .padding(8.dp),</span><br><span class="line">        onClick = &#123;</span><br><span class="line">            nameEntered.value = true</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            Text(text = stringResource(id = R.string.done))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>strings.xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;string name=&quot;hint&quot;&gt;你的名字&lt;/string&gt;</span><br><span class="line">&lt;string name=&quot;done&quot;&gt;完成&lt;/string&gt;</span><br></pre></td></tr></table></figure>
<p>上面我们创建一行，使用Row函数，在这一行里面添加一个输入框TextField和一个按钮Button。<br>输入框TextField可以传入很多参数，（注意：我们使用了value &#x3D; name.value这样的形式，这样可以不需要考虑参数的位置）但大部分是可选的。<br>TextAndButton函数要求传入两个函数，name和nameEntered。这两个参数使用了<strong>MutableState</strong>类型，MutableState对象携带的值是可变的。value 值的状态如有任何更改，系统会安排重组读取 value 的所有可组合函数，这就是可组合函数的状态与重组。至于为什么要在onValueChange和keyboardActions这两个地方修改参数的值，我将在后面进行说明。<br>Button函数我们使用alignByBaseline()使按钮和输入框基线对齐，使用padding设置按钮的内边距。</p>
<h3 id="3-显示一段问候文本"><a href="#3-显示一段问候文本" class="headerlink" title="3.显示一段问候文本"></a>3.显示一段问候文本</h3><p>我们使用Box()布局，当用户输入名字后，显示一段问候文本，否则显示输入框和按钮。<br>MainActivity.kt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun Hello()&#123;</span><br><span class="line">    val name = remember &#123; mutableStateOf(&quot;&quot;)&#125;</span><br><span class="line">    val nameEntered = remember &#123; mutableStateOf(false)&#125;</span><br><span class="line">    Box(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .fillMaxSize()</span><br><span class="line">            .padding(16.dp),</span><br><span class="line">        contentAlignment = Alignment.Center</span><br><span class="line">    )&#123;</span><br><span class="line">        if (nameEntered.value) &#123;</span><br><span class="line">            Greeting(name = name.value)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Column(horizontalAlignment = Alignment.CenterHorizontally) &#123;</span><br><span class="line">                Welcome()</span><br><span class="line">                TextAndButton(name = name, nameEntered = nameEntered)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里你可能注意到了<strong>remember</strong>和<strong>mutableStateOf</strong>，这两个关键字对可组合函数状态的创建和和控制非常重要。状态涉及到界面元素中的变量，回顾前面的Welcome函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun Welcome() &#123;</span><br><span class="line">    Text(text = stringResource(id = R.string.welcome),</span><br><span class="line">    style = MaterialTheme.typography.subtitle1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Welcome()可以说是无状态的，因为他重新编译的值始终保持不变。而Hello()是有状态的，因为它使用name和nameEntered变量，传递给TextAndButton()，并在那里进行修改，使得它不断变化。<br>前面提到的，为什么要在onValueChange和keyboardActions这两个地方修改参数的值？TextAndButton()在onValueChange的地方组件状态会发生改变，我们以参数的形式，由Hello()组件传递进来，使TextAndButton()由有状态变为无状态，方便不同的情况调用，这种模式称为<strong>状态提升</strong>。所以<strong>状态提升是一种将状态移至可组合项的调用方以使可组合项无状态的模式</strong>。<br>我们编写了一个Composable函数之后，需要确认UI编写是否正确并对细节进行微调，这时候就需要使用Compose的预览函数。</p>
<h2 id="（二）使用预览函数"><a href="#（二）使用预览函数" class="headerlink" title="（二）使用预览函数"></a>（二）使用预览函数</h2><h3 id="1-带参数的预览函数"><a href="#1-带参数的预览函数" class="headerlink" title="1.带参数的预览函数"></a>1.带参数的预览函数</h3><p>使用Compose的预览函数，我们需要在Composable函数上再添加一个注解**@Preview**，如果我们在Greeting(name: String)上面添加@Preview，你会看到程序报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Composable functions with non-default parameters are not supported in Preview unless they are annotated with @PreviewParameter. </span><br></pre></td></tr></table></figure>
<p>所以，我们应该怎么预览带参数的Composable函数呢？<br>最简单的方法，是给改函数外面再包上一层不带参数的Composable函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Preview</span><br><span class="line">@Composable</span><br><span class="line">fun PreviewGreeting()&#123;</span><br><span class="line">    Greeting(name = &quot;Jetpack Compose&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着我们每次都需要重新写一个多余的函数来达到预览的效果。如果我们带参数的可组合函数非常多，这样工作量就会非常大。<br>好在我们还有其他方法，例如，我们可以加一个函数参数的默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Preview</span><br><span class="line">@Composable</span><br><span class="line">fun Greeting(name: String = &quot;Jetpack Compose&quot;) &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = stringResource(id = R.string.hello,name),</span><br><span class="line">        textAlign = TextAlign.Center,</span><br><span class="line">        style = MaterialTheme.typography.subtitle1</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就方便很多，但同样存在一个问题，如果我们这个可组合函数不需要，或者说不能给他设置默认值，那这种方法也不可行。<br>根据提示，使用**@PreviewParameter**，我们可以给可组合函数传递参数值只影响预览函数。这个方法有一点麻烦之处在于，我们需要编写一个新的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class HelloProvider: PreviewParameterProvider&lt;String&gt; &#123;</span><br><span class="line">    override val values: Sequence&lt;String&gt;</span><br><span class="line">    get() = listOf(&quot;PreviewParameterProvider&quot;).asSequence()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们只需要在composable函数里面添加@PreviewParameter注解，这个类就会提供一个参数给预览函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Preview</span><br><span class="line">@Composable</span><br><span class="line">fun Greeting(@PreviewParameter(HelloProvider::class)name: String) &#123;</span><br><span class="line">    Text(</span><br><span class="line">        text = stringResource(id = R.string.hello,name),</span><br><span class="line">        textAlign = TextAlign.Center,</span><br><span class="line">        style = MaterialTheme.typography.subtitle1</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于带参数的预览函数，以上几种方法都可以使用，根据个人喜好和具体情况而定。此外，@Preview注解还可以通过设置一些参数，来修改预览界面的外观。</p>
<h3 id="2-Preview注解参数配置"><a href="#2-Preview注解参数配置" class="headerlink" title="2.@Preview注解参数配置"></a>2.@Preview注解参数配置</h3><p>我们可以为预览设置背景颜色，当然，首先要确认设置显示背景为true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Preview(showBackground = true, backgroundColor = 0xffff0000)</span><br><span class="line">@Composable</span><br><span class="line">fun DefaultPreview() &#123;</span><br><span class="line">    Hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/12661360-3fcf15af7a011614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HelloWord红色背景"></p>
<p>同理，预览的尺寸一般是自适应的，但是我们也可以为预览设置固定的宽高。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Preview(widthDp = 100, heightDp = 100)</span><br><span class="line">@Composable</span><br><span class="line">fun DefaultPreview() &#123;</span><br><span class="line">    Hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试多国语言的时候，如果我们在string-zh-rCN里设置了翻译语言，就可以通过locale参数，设置预览显示的语言。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Preview(locale = &quot;zh-rCN&quot;)</span><br><span class="line">@Composable</span><br><span class="line">fun DefaultPreview() &#123;</span><br><span class="line">    Hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想显示状态栏和动作栏，我们可以设置showSystemUi：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Preview(showSystemUi = true)</span><br><span class="line">@Composable</span><br><span class="line">fun DefaultPreview() &#123;</span><br><span class="line">    Hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-分组预览"><a href="#3-分组预览" class="headerlink" title="3.分组预览"></a>3.分组预览</h3><p>当代码中我们设置了多个预览函数时，我们可以选择这些预览函数在右侧预览面板以网格或者垂直的方式展示。<br><img src="https://upload-images.jianshu.io/upload_images/12661360-c85db92c6878b4a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分组预览"><br>当我们代码中设置了非常多的预览函数，导致预览面板看起来十分混乱，这时我们可以设置在右侧预览面板上面进行分组预览。<br>新建一个预览分组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Preview(group = &quot;group1&quot;)</span><br><span class="line">@Composable</span><br><span class="line">fun Welcome() &#123;</span><br><span class="line">    Text(text = stringResource(id = R.string.welcome),</span><br><span class="line">    style = MaterialTheme.typography.subtitle1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切换分组视图：<br><img src="https://upload-images.jianshu.io/upload_images/12661360-c96dd6d7fa92056a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="切换分组视图"></p>
<h2 id="（三）运行Compose应用"><a href="#（三）运行Compose应用" class="headerlink" title="（三）运行Compose应用"></a>（三）运行Compose应用</h2><p>如果我们想看看界面UI及一些交互操作在模拟器及真机上的效果，我们可以通过以下两个方式：</p>
<ul>
<li>部署Composable函数</li>
<li>运行App<h3 id="1-部署Composable函数"><a href="#1-部署Composable函数" class="headerlink" title="1.部署Composable函数"></a>1.部署Composable函数</h3>我们在预览面板的某个预览函数的预览界面的右上角，有一个预览按钮，点击即可<strong>部署</strong>到真机或模拟器上，这种方法比较适合调试单个Composable函数的时候。<br><img src="https://upload-images.jianshu.io/upload_images/12661360-b1d18eacf91efebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="部署函数"><br>这种方法会为我们自动创建运行配置，我们可以在Run&#x2F;Debug Comfigurations里面进行修改。</li>
</ul>
<h3 id="2-在Activity上使用Composable函数"><a href="#2-在Activity上使用Composable函数" class="headerlink" title="2.在Activity上使用Composable函数"></a>2.在Activity上使用Composable函数</h3><p>普通情况下，我们新建的工程，在AndroidManifest.xml项目里面就将MainActivity设置为启动界面。并在MainActivity里设置它对应的布局。同样的，使用Compose时，我们也需要在Activity里面绑定Compose表示的界面。</p>
<p>MainActivity.kt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : ComponentActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            Welcome()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过setContent{ }就可以简洁明了地设置对应的布局。与之前的setContentView()相比，使用Jetpack Compose，不需要维护对UI组件树或其单个元素的引用。这点我们会在后面详细介绍。</p>
<h3 id="3-项目的配置"><a href="#3-项目的配置" class="headerlink" title="3.项目的配置"></a>3.项目的配置</h3><p>Jetpack Compose依赖Kotlin编写，这意味着我们的应用程序项目必须配置为Kotlin工程，但这并不意味着我们完全不能使用Java。事实上，只要我们的可组合函数是用Kotlin编写的，就可以在项目中轻松地混合Kotlin和Java，同时也可以混合使用传统视图和可组合视图。关于这个<strong>互操作性</strong>API主题我们将在后面详细介绍。<br>在创建项目的时候，我们只需要选择Empty Compose Activity，AndroidStudio就会为我们做好一个Compose项目的所有配置。<br><img src="https://upload-images.jianshu.io/upload_images/12661360-ed0142d880cf814d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建Compose项目"><br>这包括在项目级别的build.gradle里面对Kotlin的引用和配置，API版本不低于21，及在应用级别的build.gradle里面引入compose相关的依赖库。</p>
<h3 id="4-点击运行按钮"><a href="#4-点击运行按钮" class="headerlink" title="4.点击运行按钮"></a>4.点击运行按钮</h3><p><strong>运行</strong>我们的App，首先确定我们运行的app（下图的app处）是否已选择，并确认我们要运行的设备（下图的Pixel XL API 30处）是否已选择，然后点击绿色播放按钮，即可成功运行我们的应用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12661360-9bc24e8a7a714fba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行程序"></p>
<p>至此，我们开发的第一HelloWorld应用就顺利完成了！</p>
<h2 id="（四）总结回顾"><a href="#（四）总结回顾" class="headerlink" title="（四）总结回顾"></a>（四）总结回顾</h2><p>###1.总结<br>这一章，我们学习了如何编写我们的第一个Compose程序，并成功运行到设备上。同时，在编写代码的过程中，我们了解到了如何使用@Composable注解编写一个可组合函数，及如何使用@Preview注解在预览面板预览可组合函数。另外，对可组合函数的状态与重组及状态提升等概念也有了基本的了解。</p>
<p>###2.回顾</p>
<p><strong>关键术语</strong><br>@Composable<br>带参数的字符串<br>三大布局基础布局（Row&#x2F;Column&#x2F;Box）<br>remember<br>mutableStateOf<br>可组合函数的状态与重组<br>状态提升<br>@Preview<br>@PreviewParameter<br>项目的部署与运行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/06/%E7%AC%AC1%E7%AB%A0%20%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AACompose%E5%BA%94%E7%94%A8/" data-id="cl4ab2nqs00010v5t1jyp8wt2" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  
  
  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>鸭梨西瓜大 &copy; 2022</li>
      
        <li></li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="鸭梨西瓜大"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">首页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>